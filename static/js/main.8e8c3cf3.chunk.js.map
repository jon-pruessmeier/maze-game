{"version":3,"sources":["gameplay-components/Description.js","mazebuilder-components/Field.js","mazebuilder-components/Maze.js","gameplay-components/PlayableMaze.js","gameplay-components/GameScreen.js","gameplay-components/buttons/arrow_up.png","gameplay-components/buttons/arrow_right.png","gameplay-components/buttons/arrow_down.png","gameplay-components/buttons/arrow_left.png","gameplay-components/Game.js","index.js"],"names":["Description","className","href","Field","x","y","id","this","algo","info","rows","columns","possibleDirections","positions","Y","top","X","right","bottom","left","containsPlayer","containsGoal","visited","wallInfo","walls","borderStyle","push","wallInfoBorders","getBorderStyle","borders","playerJSX","goalJSX","emptyJSX","style","i","antiDirections","PlayableMaze","m","n","partialMaze","maze","length","j","actualPlayerX","actualPlayerY","JSX","getDivElement","play","direction","changePlayer","elementsJSX","createJSXElement","z","Array","deleteWallsAtBorders","createMaze","movableDirections","field","getVisitedStatus","counter","arr","actualField","lastFieldsCoordinates","counterUnvisitedFields","moveFieldAlgorithm","randomRowIndex","Math","floor","random","randomColumnIndex","changeGoal","setVisited","array","getExistingNeighbours","getUnvisitedNeighbors","countMovableDirections","directionsArray","getDirectionsArray","nextFieldCoordinates","getNewCoordinates","nextFieldX","nextFieldY","coordinatesActualField","antiDirection","coordinatesLastField","pop","GameScreen","checkWin","setTimeout","winner","document","getElementsByClassName","console","log","window","confirm","refresh","descriptionDiv","playableMaze","up","e","mazeDiv","render","down","buttonUp","onClick","src","alt","buttonRight","buttonDown","buttonLeft","navField","createButtonDiv","updateDiv","elementJSX","ReactDOM","getDiv","getElementById","Game"],"mappings":"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","file":"static/js/main.8e8c3cf3.chunk.js","sourcesContent":["//info: CSS-properties are defined in GameScreen.css\r\n\r\nconst Description = (\r\n        <div className={\"description\"} key={\"description\"}>\r\n            <h2>The Maze Game by Jón Prüßmeier</h2>\r\n            <h4>About the Game:</h4>\r\n            <p>The player (green field) and the goal (red field) appear at random positions. Using the arrow buttons,\r\n                the player can move inside the maze.\r\n                Have fun!\r\n            </p>\r\n            <h4>About the Algorithm of the Maze-creation:</h4>\r\n            <p>\r\n                The maze-generating algorithm is a backtracking algorithm that uses recursion.\r\n                This algorithm is used for heuristic problem solving and is based on the trial and error principle.\r\n            </p>\r\n            <p>\r\n                The maze starts as a grid and each square has walls on all sides.\r\n                The algorithm starts in the top-left field and now switches to a random adjacent and visitable field.\r\n                Each field stores whether it has already been visited and whether the algorithm has changed anything within the wall properties.\r\n                If the algorithm encounters a field which is surrounded only by already visited fields,\r\n                it backtracks until a field is found that has at least one unvisited adjacent field.\r\n                This is how dead ends in the maze are created. The termination condition of the recursion is a counter of all unvisited fields.\r\n            </p>\r\n            <p>\r\n                See also:  <a href=\"https://en.wikipedia.org/wiki/Backtracking#:~:text=Backtracking%20is%20a%20general%20algorithm,completed%20to%20a%20valid%20solution.\">\r\n                wikipedia.org/wiki/Backtracking</a>\r\n            </p>\r\n        </div>\r\n\r\n);\r\n\r\nexport default Description;","import './Field.css';\r\n\r\nclass Field {\r\n\r\n    constructor(x, y){ //x and y are the positions of the field in the maze\r\n\r\n        //creating a variable for the info-object, since template-strings are not available in JSON\r\n        let id = `field-${x}-${y}`;\r\n        this.algo = false; //tracks if the algorithm is actually on this field\r\n\r\n        //object with every important information about the field\r\n        //the constructor sets the default values for all containing information\r\n        this.info = {\r\n            //contains information about the surrounding walls of the field\r\n            \"walls\": {\r\n                \"top\": true,\r\n                \"right\": true,\r\n                \"bottom\": true,\r\n                \"left\": true\r\n            },\r\n            \"visited\": false, //if this field was visited by the maze-generating-algorithm\r\n            \"positions\": {\r\n                \"X\": x, //x-Position of the field in the maze (starting with 0 on the left)\r\n                \"Y\": y  //y-Position of the field in the maze (starting with 0 at the top)\r\n            },\r\n            \"containsPlayer\": false, //if the player is on this field\r\n            \"containsGoal\": false, //if the goal is on this field\r\n            \"id\": id // Format: field-X-Y (e.g. \"field-5-9\") like in the first line of the constructor\r\n        };\r\n    };\r\n\r\n    //gives back all existing neighbours of the field by recognizing the size of the maze\r\n    getExistingNeighbours(rows, columns){\r\n        let possibleDirections = {\r\n            \"top\": true,\r\n            \"right\": true,\r\n            \"bottom\": true,\r\n            \"left\": true\r\n        };\r\n\r\n        let positions = this.info.positions;\r\n        if (positions.Y === 0){\r\n            possibleDirections.top = false;\r\n        }\r\n        if (positions.X === columns - 1){\r\n            possibleDirections.right = false;\r\n        }\r\n        if (positions.Y === rows - 1){\r\n            possibleDirections.bottom = false;\r\n        }\r\n        if (positions.X === 0){\r\n            possibleDirections.left = false;\r\n        }\r\n\r\n        return possibleDirections;\r\n    };\r\n\r\n    changePlayer(){\r\n        if(this.info.containsPlayer){\r\n            this.info.containsPlayer = false;\r\n        } else {\r\n            this.info.containsPlayer = true;\r\n        }\r\n    }\r\n\r\n    changeGoal(){\r\n        if(this.info.containsGoal){\r\n            this.info.containsGoal = false;\r\n        } else {\r\n            this.info.containsGoal = true;\r\n        }\r\n    }\r\n\r\n    getVisitedStatus(){\r\n        return this.info.visited;\r\n    }\r\n\r\n    setVisited(){\r\n        this.info.visited = true;\r\n    }\r\n\r\n    //This method return information about the border-style of each wall of the field-div\r\n    getBorderStyle(){\r\n        let wallInfo = this.info.walls;\r\n        let top = wallInfo.top;\r\n        let right = wallInfo.right;\r\n        let bottom = wallInfo.bottom;\r\n        let left = wallInfo.left;\r\n        let borderStyle = [];\r\n\r\n        if (top){\r\n            borderStyle.push(\"solid\");\r\n        } else {\r\n            borderStyle.push(\"none\");\r\n        }\r\n\r\n        if (right){\r\n            borderStyle.push(\"solid\");\r\n        } else {\r\n            borderStyle.push(\"none\");\r\n        }\r\n\r\n        if (bottom){\r\n            borderStyle.push(\"solid\");\r\n        } else {\r\n            borderStyle.push(\"none\");\r\n        }\r\n\r\n        if (left){\r\n            borderStyle.push(\"solid\");\r\n        } else {\r\n            borderStyle.push(\"none\");\r\n        }\r\n\r\n        return borderStyle;\r\n\r\n    }\r\n\r\n    //returns the div that represents the visual Field\r\n    getDivElement() {\r\n        let wallInfoBorders = this.getBorderStyle();\r\n        let top = wallInfoBorders[0];\r\n        let right = wallInfoBorders[1];\r\n        let bottom = wallInfoBorders[2];\r\n        let left = wallInfoBorders[3];\r\n\r\n        let borders = {\r\n            borderStyle: `${top} ${right} ${bottom} ${left}`\r\n        }\r\n\r\n        const playerJSX = (<div id=\"player\"></div>);\r\n        const goalJSX = (<div id=\"goal\"></div>);\r\n        const emptyJSX = (<div className=\"empty\"></div>);\r\n\r\n        let div;\r\n        if (this.info.containsPlayer && this.info.containsGoal){\r\n            div = (\r\n                <div className={`field win`} id={this.info.id} key={this.info.id} style={borders}>\r\n                        <div id=\"goal\">\r\n                            <div id=\"player\"></div>\r\n                        </div>\r\n                </div>\r\n            );\r\n        } else {\r\n            div = (\r\n                <div className={`field`}  id={this.info.i} key={this.info.id} style={borders}>\r\n                    {this.info.containsPlayer ? playerJSX : emptyJSX}\r\n                    {this.info.containsGoal ? goalJSX : emptyJSX}\r\n                </div>\r\n            );\r\n        }\r\n\r\n        return div;\r\n    }\r\n}\r\n\r\nexport default Field;","import Field from './Field.js'\r\nimport './Maze.css'\r\n\r\n//This function returns a random element of an array.\r\nconst getRandomElementOfArray = (array) => {\r\n    return array[Math.floor(Math.random()*array.length)];\r\n}\r\n\r\nconst antiDirections = {\r\n    \"top\": \"bottom\",\r\n    \"right\": \"left\",\r\n    \"bottom\": \"top\",\r\n    \"left\": \"right\"\r\n}\r\n\r\nclass Maze {\r\n\r\n    constructor(m, n) { //partialMaze is a boolean which defines if this maze is a PartialMaze\r\n        this.z = 1;\r\n\r\n        this.rows = m;\r\n        this.columns = n;\r\n\r\n        this.maze = new Array(m);\r\n        for (let i = 0; i < m; i++) {\r\n            this.maze[i] = new Array(n);\r\n        }\r\n        for (let i = 0; i < m; i++){\r\n            for (let j = 0; j < n; j++){\r\n                this.maze[i][j] = new Field(j, i); //j is the x-Position, i is the y-Position\r\n            }\r\n        }\r\n\r\n        this.deleteWallsAtBorders();\r\n\r\n        /*\r\n        For the Visualization-Feature:\r\n\r\n        this.arrayJSX = [];\r\n        this.arrayJSX.push(this.getDivElement());\r\n         */\r\n\r\n\r\n        this.createMaze();\r\n\r\n\r\n    }\r\n\r\n    //deletes all borders of the fields that are at the border of the maze (e.g. the top-border of the fields in the first row)\r\n    //if these borders won't be deleted, a visual effect of double-borders happens at the borders of the maze\r\n    deleteWallsAtBorders(){\r\n        //deleting the walls at the top-border:\r\n        for (let i = 0; i < this.maze[0].length; i++){\r\n            this.maze[0][i].info.walls.top = false;\r\n        }\r\n\r\n        //deleting the walls at the right-border:\r\n        for (let i = 0; i < this.maze.length; i++){\r\n            this.maze[i][this.maze[i].length - 1].info.walls.right = false;\r\n        }\r\n\r\n        //deleting the walls at the bottom-border:\r\n        for (let i = 0; i < this.maze.length; i++){\r\n            this.maze[this.maze.length - 1][i].info.walls.bottom = false;\r\n        }\r\n\r\n        //deleting the walls at the left-border:\r\n        for (let i = 0; i < this.maze[0].length; i++){\r\n            this.maze[i][0].info.walls.left = false;\r\n        }\r\n\r\n    }\r\n\r\n    //modifies an object of directions that are movable (= they would not cause an IndexOutOufBoundsException) to an object\r\n    //containing additional information about neighbours that are unvisited\r\n    getUnvisitedNeighbors(movableDirections, field){\r\n        let x = field.info.positions.X;\r\n        let y = field.info.positions.Y;\r\n        if (movableDirections.top){\r\n            if (this.maze[y-1][x].getVisitedStatus()){\r\n                movableDirections.top = false;\r\n            }\r\n        }\r\n        if (movableDirections.right){\r\n            if (this.maze[y][x+1].getVisitedStatus()){\r\n                movableDirections.right = false;\r\n            }\r\n        }\r\n        if (movableDirections.bottom){\r\n            if (this.maze[y+1][x].getVisitedStatus()){\r\n                movableDirections.bottom = false;\r\n            }\r\n        }\r\n        if (movableDirections.left){\r\n            if (this.maze[y][x-1].getVisitedStatus()){\r\n                movableDirections.left = false;\r\n            }\r\n        }\r\n        return movableDirections;\r\n    }\r\n\r\n    countMovableDirections(movableDirections){\r\n        let counter = 0;\r\n        if (movableDirections.top){\r\n            counter++;\r\n        }\r\n        if (movableDirections.right){\r\n            counter++;\r\n        }\r\n        if (movableDirections.bottom){\r\n            counter++;\r\n        }\r\n        if (movableDirections.left){\r\n            counter++;\r\n        }\r\n        return counter++;\r\n    }\r\n\r\n    getDirectionsArray(movableDirections){\r\n        let arr = []\r\n        if (movableDirections.top){\r\n            arr.push(\"top\");\r\n        }\r\n        if (movableDirections.right){\r\n            arr.push(\"right\");\r\n        }\r\n        if (movableDirections.bottom){\r\n            arr.push(\"bottom\");\r\n        }\r\n        if (movableDirections.left){\r\n            arr.push(\"left\");\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    //accepts a direction and a field and returns an array with the coordinates (format [x, y]) of the neighbouring field\r\n    getNewCoordinates(direction, actualField){\r\n        let x = actualField.info.positions.X;\r\n        let y = actualField.info.positions.Y;\r\n        if (direction === \"top\"){\r\n            return [x, y-1];\r\n        } else if (direction === \"right\"){\r\n            return [x+1, y];\r\n        } else if (direction === \"bottom\"){\r\n            return [x, y+1];\r\n        } else if (direction === \"left\"){\r\n            return  [x-1, y];\r\n        }\r\n    }\r\n\r\n    createMaze(){\r\n        //tracks the coordinates of the last visited fields\r\n        //is used as a stack with the push- and pop-methods\r\n        this.lastFieldsCoordinates = new Array();\r\n\r\n        //tracks the number of all fields in the maze and gets decremented by every visited field by the algorithm\r\n        //this variable is the termination condition of the recursion in the moveFieldAlgorithm-method\r\n        this.counterUnvisitedFields = this.rows * this.columns;\r\n\r\n        this.moveFieldAlgorithm(this.maze[0][0]); //starting the algorithm with the field in the top-left of the maze\r\n\r\n        //This code-block assigns a random field in the maze as the field with the player on it.\r\n        let randomRowIndex = Math.floor(Math.random()*this.rows);\r\n        let randomColumnIndex = Math.floor(Math.random()*this.columns);\r\n        this.maze[randomRowIndex][randomColumnIndex].changePlayer();\r\n\r\n        //This code-block assigns a random field in the maze as the field with the goal on it.\r\n        randomRowIndex = Math.floor(Math.random()*this.rows);\r\n        randomColumnIndex = Math.floor(Math.random()*this.columns);\r\n        this.maze[randomRowIndex][randomColumnIndex].changeGoal();\r\n\r\n    }\r\n\r\n\r\n    /*\r\n    This method is the heart of the maze-generation. It takes a field as parameter, chooses a next field by randomness,\r\n    deletes the wall between the actual and the next field and then visits the next field by recursion. If the field has no visitable\r\n    neighbours, it returns to the last visited field until a field has a visitable neighbour. The recursion of this method stops when\r\n    the counterUnvisitedFields-variable of the Maze-class is zero, because then the creation of the maze has finished.\r\n    Furthermore, it keeps track of the past fields by using the lastFieldsCoordinates-Array of the createMaze()-method and uses the counterUnvisitedFields-variable\r\n    which is used for counting the number of remaining fields.\r\n     */\r\n\r\n    moveFieldAlgorithm(field){\r\n\r\n        if (field.info.visited === false){\r\n            field.setVisited();\r\n            this.counterUnvisitedFields--;\r\n        }\r\n\r\n        /*\r\n        This code-block is also for the planned Visualization-feature:\r\n\r\n        field.algo = true;\r\n        this.arrayJSX.push(this.getDivElement());\r\n        field.algo = false;\r\n         */\r\n\r\n\r\n        //creating the variable movableDirections that keeps track of every possible direction\r\n        //(by regarding the visited-status of neighbouring fields and IndexOutOfBoundsExceptions)\r\n        let movableDirections = field.getExistingNeighbours(this.rows, this.columns);\r\n        movableDirections = this.getUnvisitedNeighbors(movableDirections, field);\r\n        let counterDirections = this.countMovableDirections(movableDirections);\r\n\r\n        if (counterDirections > 0){ //counterDirections > 0 means that this field has neighbouring fields that are possible to visit\r\n\r\n\r\n            //The following code-block generates the coordinates of the next field for the algorithm by getting a random possible direction\r\n\r\n            let directionsArray = this.getDirectionsArray(movableDirections); // directions is an array that stores every available direction of the movableDirection-object\r\n            let direction = getRandomElementOfArray(directionsArray);\r\n            let nextFieldCoordinates = this.getNewCoordinates(direction, field);\r\n            let nextFieldX = nextFieldCoordinates[0];\r\n            let nextFieldY = nextFieldCoordinates[1];\r\n\r\n            let coordinatesActualField = [field.info.positions.X, field.info.positions.Y];\r\n            this.lastFieldsCoordinates.push(coordinatesActualField); //saving the actual coordinates or the backtracking algorithm\r\n\r\n\r\n            //The following code-block actualizes the wall-info of the actual and the next field in order to delete the existing wall\r\n            field.info.walls[direction] = false;\r\n            let antiDirection = antiDirections[direction];\r\n            this.maze[nextFieldY][nextFieldX].info.walls[antiDirection] = false;\r\n\r\n\r\n            if (this.counterUnvisitedFields > 0){\r\n                this.moveFieldAlgorithm(this.maze[nextFieldY][nextFieldX], this.lastFieldsCoordinates, );\r\n            }\r\n\r\n\r\n        } else {\r\n            if ( this.counterUnvisitedFields > 0){\r\n                let coordinatesLastField = this.lastFieldsCoordinates.pop(); //array with the format [x,y]\r\n                //returning back to the last visited fields until one has 1 or more possible neighbouring field\r\n                this.moveFieldAlgorithm(this.maze[coordinatesLastField[1]][coordinatesLastField[0]], this.lastFieldsCoordinates, );\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n    createJSXElement(){\r\n        let mazeJSX;\r\n        let elementsJSX = [];\r\n        for (let i = 0; i < this.maze.length; i++){\r\n            for (let j = 0; j < this.maze[i].length; j++){\r\n                elementsJSX.push(this.maze[i][j].getDivElement());\r\n            }\r\n        }\r\n\r\n        mazeJSX = (\r\n            <div id=\"maze\" key={\"maze\"}>\r\n                {elementsJSX}\r\n            </div>\r\n        );\r\n\r\n        return mazeJSX;\r\n\r\n    }\r\n\r\n    getDivElement(){\r\n        return this.createJSXElement();\r\n    }\r\n}\r\n\r\nexport default Maze;","import Maze from \"../mazebuilder-components/Maze\";\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\n//info: CSS-properties are defined in GameScreen.css\r\n\r\n\r\nclass PlayableMaze extends Maze{\r\n    constructor(m, n, partialMaze) {\r\n        super(m, n, partialMaze);\r\n\r\n        for (let i = 0; i < this.maze.length; i++){\r\n            for (let j = 0; j < this.maze[i].length; j++){\r\n                if (this.maze[i][j].info.containsPlayer){\r\n                    this.actualPlayerX = j;\r\n                    this.actualPlayerY = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.JSX = this.getDivElement();\r\n\r\n        this.play = (direction) => {\r\n\r\n            let x = this.actualPlayerX;\r\n            let y = this.actualPlayerY;\r\n            let walls = this.maze[y][x].info.walls;\r\n\r\n            if(direction === \"up\"){\r\n                if(y > 0 && walls.top === false){\r\n                    this.maze[y][x].changePlayer();\r\n                    this.maze[y-1][x].changePlayer();\r\n                    this.actualPlayerY = y-1;\r\n                }\r\n            } else if (direction === \"right\") {\r\n                if (x < this.columns - 1 && walls.right === false) {\r\n                    this.maze[y][x].changePlayer();\r\n                    this.maze[y][x+1].changePlayer();\r\n                    this.actualPlayerX = x + 1;\r\n                }\r\n\r\n\r\n            } else if (direction === \"down\") {\r\n                if (y < this.rows - 1 && walls.bottom === false) {\r\n                    this.maze[y][x].changePlayer();\r\n                    this.maze[y + 1][x].changePlayer();\r\n                    this.actualPlayerY = y + 1;\r\n                }\r\n\r\n            } else if (direction === \"left\") {\r\n                if (x > 0 && walls.left === false) {\r\n                    this.maze[y][x].changePlayer();\r\n                    this.maze[y][x - 1].changePlayer();\r\n                    this.actualPlayerX = x - 1;\r\n                }\r\n\r\n            }\r\n            this.JSX = this.getDivElement();\r\n\r\n        }\r\n    }\r\n\r\n    createJSXElement(){\r\n        let mazeJSX;\r\n        let elementsJSX = [];\r\n        for (let i = 0; i < this.maze.length; i++){\r\n            for (let j = 0; j < this.maze[i].length; j++){\r\n                elementsJSX.push(this.maze[i][j].getDivElement());\r\n            }\r\n        }\r\n\r\n        mazeJSX = (\r\n            <div id=\"playableMaze\" key={\"playableMaze\"}>\r\n                {elementsJSX}\r\n            </div>\r\n        );\r\n\r\n        return mazeJSX;\r\n\r\n    }\r\n\r\n    getDivElement(){\r\n        return this.createJSXElement();\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default PlayableMaze;","import ReactDOM from \"react-dom\";\r\nimport React from \"react\";\r\nimport Description from \"./Description\";\r\nimport PlayableMaze from \"./PlayableMaze\";\r\nimport \"./GameScreen.css\"\r\n\r\nimport arrowUp from \"./buttons/arrow_up.png\";\r\nimport arrowRight from \"./buttons/arrow_right.png\";\r\nimport arrowDown from \"./buttons/arrow_down.png\";\r\nimport arrowLeft from \"./buttons/arrow_left.png\";\r\n\r\nclass GameScreen {\r\n\r\n    constructor(){\r\n\r\n        this.descriptionDiv = Description;\r\n        this.playableMaze = new PlayableMaze(20, 20);\r\n\r\n\r\n        this.up = (e) => {\r\n            this.playableMaze.play(\"up\");\r\n            this.mazeDiv = this.playableMaze.getDivElement();\r\n            this.render();\r\n        }\r\n\r\n        this.right = (e) => {\r\n            this.playableMaze.play(\"right\");\r\n            this.mazeDiv = this.playableMaze.getDivElement();\r\n            this.render();\r\n        }\r\n\r\n        this.down = (e) => {\r\n            this.playableMaze.play(\"down\");\r\n            this.mazeDiv = this.playableMaze.getDivElement();\r\n            this.render();\r\n        }\r\n\r\n        this.left = (e) => {\r\n            this.playableMaze.play(\"left\");\r\n            this.mazeDiv = this.playableMaze.getDivElement();\r\n            this.render();\r\n        }\r\n\r\n        this.buttonUp = <button onClick={this.up} key={\"upButton\"}><img src={arrowUp} className={\"buttonTopDown\"} alt={\"arrow-up button\"} /*width=\"70\" height=\"105\"*//></button>;\r\n        this.buttonRight = <button onClick={this.right} key={\"rightButton\"}><img src={arrowRight} className={\"buttonRightLeft\"} alt={\"arrow-right button\"} /*width=\"70\" height=\"105\"*//></button>;\r\n        this.buttonDown = <button onClick={this.down} key={\"leftButton\"}><img src={arrowDown} className={\"buttonTopDown\"} alt={\"arrow-down button\"} /*width=\"70\" height=\"105\"*//></button>;\r\n        this.buttonLeft = <button onClick={this.left} key={\"downButton\"}><img src={arrowLeft} className={\"buttonRightLeft\"} alt={\"arrow-left button\"} /*width=\"70\" height=\"105\"*//></button>;\r\n        this.navField = this.createButtonDiv();\r\n\r\n        this.updateDiv = () => {\r\n            this.mazeDiv = this.playableMaze.getDivElement();\r\n            return (<div className={\"gameScreen\"}>\r\n                {this.descriptionDiv}\r\n                <div className={\"mazeContainer\"}>\r\n                    {this.mazeDiv}\r\n                </div>\r\n                {this.navField}\r\n            </div>)\r\n        };\r\n\r\n        this.elementJSX = this.updateDiv();\r\n    }\r\n\r\n    getDiv(){\r\n        this.elementJSX = this.updateDiv();\r\n        return this.elementJSX;\r\n    }\r\n\r\n    checkWin = () => {\r\n        setTimeout(() => {\r\n            //checks if the player is on the same field as the goal (then the div of the field has the additional className \"win\"\r\n            let winner = document.getElementsByClassName(\"win\");\r\n            console.log(winner);\r\n            console.log(winner.length);\r\n            if (winner.length > 0) {\r\n                let okay = window.confirm(\"You won! Do you want to play again?\");\r\n                if (okay){\r\n                    this.refresh();\r\n                }\r\n            }\r\n        }, 500);\r\n    }\r\n\r\n    createButtonDiv(){\r\n        let div = (\r\n            <div className = \"buttonContainer\">\r\n                <div id={\"leftButton\"}>\r\n                    {this.buttonLeft}\r\n                </div>\r\n                <div id={\"upDownButton\"}>\r\n                    {this.buttonUp}\r\n                    {this.buttonDown}\r\n                </div>\r\n                <div id={\"rightButton\"}>\r\n                    {this.buttonRight}\r\n                </div>\r\n            </div>\r\n        );\r\n        return div;\r\n    }\r\n\r\n    render(){\r\n        ReactDOM.render(\r\n            this.getDiv(),\r\n            document.getElementById(\"root\")\r\n        );\r\n        this.checkWin();\r\n    }\r\n\r\n    refresh(){\r\n        this.playableMaze = new PlayableMaze(20,20);\r\n        this.render();\r\n    }\r\n\r\n}\r\n\r\n\r\nexport default GameScreen;","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ0AAAGKCAMAAAAheeRaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJUExURQAAAAAAAAAAAINj6cAAAAACdFJOUwCV9vaq8wAAAAlwSFlzAAAywAAAMsABKGRa2wAABtdJREFUeF7t1EmSG0cUBUGS9z+0OAQlNdkDGqgqzwG++bu0sLfIL2P42n367uu35xz/+vrt23OO336M8Zwjv8Z4zvHT7zGec3z33xjPOV6Msf0cL8fYfI4/x9h6jr/H2HiO18bYdo7Xx9h0jrfG2HKOt8fYcI73xthujvfH2GyOj8bYao6Px9hojlvG2GaO28bYZI5bx9hijtvH2GCOz4yx/ByfG2PxOT47xtJzfH6Mhee4Z4xl57hvjEXnuHeMJee4f4wF53hkjOXmeGyMxeZ4dIyl5nh8jIXmOGKMZeY4ZoxF5jhqjCXmOG6MBeY4cozp5zh2jMnnOHqMqec4foyJ5zhjjGnnOGeMSec4a4wp5zhvjAnnOHOM6eY4d4zJ5jh7jKnmOH+Miea4Yoxp5rhmjEnmuGqMKea4bowJ5rhyjOHnuHaMwee4eoyh57h+jIHnEGMMO4cZY9A51BhDzuHGGHAOOcZwc9gxBptDjzHUHH6MgeYYYYxh5hhjjEHmGGWMIeYYZ4wB5hhpDD7HWGPgOUYbg84x3hhwjhHHYHOMOQaaY9QxyBzjjgHmGHmMy+cYe4yL5xh9jEvnGH+MC+eYYYzL5phjjIvmmGWMS+aYZ4wL5phpjNPnmGuMk+eYbYxT55hvjBPnmHGM0+aYc4yT5ph1jFPmmHeME+aYeYzD55h7jIPnmH2MQ+eYf4wD51hhjMPmWGOMg+ZYZYxD5lhnjAPmWGmMh+dYa4wH51htjIfmWG+MB+ZYcYy751hzjDvnWHWMu+ZYd4w75lh5jE/PsfYYn5xj9TE+Ncf6Y3xijh3GuHmOPca4cY5dxrhpjn3GuGGOncb4cI69xvhgjt3GeHeO/cZ4Z44dx3hzjj3HeGOOXcd4dY59x3hljp3H+GuOvcf4Y47dx3gxx3OM/83xHOOH5niO8cvPOZ5j/PbiK71fr1m1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtXj1WLV49Vi1ePVYtTzgy5d/AFzDmXXH2PMYAAAAAElFTkSuQmCC\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYoAAAENCAMAAAAmFdJCAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJUExURQAAAAAAAAAAAINj6cAAAAACdFJOUwCV9vaq8wAAAAlwSFlzAAAywAAAMsABKGRa2wAABUJJREFUeF7t1kly3TgUBVGX97/okqWU9Bs2APgaDvJMLJEABzfDYf+RbuQ//lS7v7a4i7+2uIu/triLjxS2uId/KWxxC58pbHEHXylscQOksEU/StiiHyE+2KIZHf6xRS8yfLJFKyp8sUUnIsAWjWjwzRZ9SPDDFm0o8MsWXQjwwBZN2P+RLXow/xNbtGD9Z7bowPgvbNGA7V/Zoh7Tv7FFOZZ/Z4tqDL/BFsXYfYstajH7JluUYvVttqjE6DtsUYjN99iiDpPvskUZFt9niyoMfsAWRdj7iC1qMPchW5Rg7WO2qMDYJ2xRgK3P2CIfU5+yRTqWPmeLbAw9wBbJ2HmELXIx8xBbpGLlMbbIxMiDbJGIjUfZIg8TD7NFGhYeZ4ssDDzBFknYd4YtcjDvFFukYN05tsjAuJNskYBtZ9kiHtNOs0U4lp1ni2gMu8AWwdh1hS1iMesSW4Ri1TW2iMSoi2wRiE1X2SIOky6zRRgWXWeLKAx6QUgLvqVrIlrwKV0U0IIv6arrLfiQLrvcgu/ouqst+IwCXGzBVxThWgs+ohCXWvANxbjSgk8oyIUWfEFR1lvwAYVZbsF9xVltwXUFWmzBbUVaa8FlhVpqwV3FWmnBVQVbaMFNRZtvwUWFm27BPcWbbcE1JZhswS1lmGvBJaWYasEd5ZhpwRUlmWjBDWUZb8EFpRluwXnlGW3BcSUabMFpZRprwWGlGmrBWeUaacFRJRtowUllO2/BQaU7bcE55TtrwTEVOGnBKVU4bsEhlThswRnVOGrBERU5aMEJVdlvwQGV2W3Be9XZa8FrFdppwVtV2m7BS5XabME71dpqwSsV22jBG1V7b8ELlXtrwXPVe23BYzV4acFTdXhuwUO1eGrBM/V4bMEjNXlowRN1+W3BA7X5acHv6vPdgl/ViBb8pk5fLfhFrT5b8LN6/WvBj2r20YKf1O0/U9yEfyvuwn8r7sL/Qd3FZwlT3MBXCVP0o4Qp2n2XMEW3nxKmaPZbwhS9HkqYotVjCVN0eiphikbPJUzR56WEKdq8ljBFl7cSpmjyXsIUPTZKmKLFVglTdNgsYYoG2yVMUW+nhCnK7ZUwRbXdEqYotl/CFLUOSpii1FEJU1Q6LGGKQsclTFHnpIQpypyVMEWV0xKmKHJewhQ1BkqYosRICVNUGCphigJjJUyRb7CEKdKNljBFtuESpkg2XsIUuSZKmCLVTAlTZJoqYYpEcyVMkWeyhCnSzJYwRZbpEqZIMl/CFDkWSpgixUoJU2RYKmGKBGslTBFvsYQpwq2WMEW05RKmCLZewhSxLpQwRagrJUwR6VIJUwS6VsIUcS6WMEWYqyVMEeVyCVMEuV7CFDECSugDc15giSDsuc4SURh0mSXCsOgqS8Rh0kWWCMSmaywRiVGXWCIUq66wRCxmXWCJYOw6zxLRGHaaJcKx7CxLxGPaSZZIwLZzLJGBcadYIgXrzrBEDuadYIkk7DvOElkYeJgl0rDwKEvkYeJBlkjExmMskYmRh1giFSuPsEQuZh5giWTsfM4S2Rj6lCXSsfQZS+Rj6hOWKMDWxyxRgbEPWaIEax+xRA3mPmCJIuy9zxJVGHyXJcqw+B5L1GHyHZYoxObbLFGJ0TdZohSrb7FELWbfYIli7P7OEtUY/o0lyrH8K0vUY/oXlmjA9s8s0YHxn1iiBes/skQP5n9giSbs/8sSXQjwwxJtKPDNEn1IAEs0osEXS3QiwidLtKLCP5boRYYPlmhGB0v0I4Ql+lniNixxG5a4DUvchiVuwxK3YYnbsIQe/PnzP6skmXXJRlJXAAAAAElFTkSuQmCC\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ0AAAGKCAMAAAAheeRaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJUExURQAAAAAAAAAAAINj6cAAAAACdFJOUwCV9vaq8wAAAAlwSFlzAAAywAAAMsABKGRa2wAABs1JREFUeF7t0Iex3FYABEFS+QctURxRNN+cAdDPXAewNbVfjvDXCGrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFq8eqxavHqsWrx6rFqedLX1l6+vu74379nvO74rjNed3zz44zXHb+c8brjlzN2v+O3M/a+448zdr7jjTP2vePNM3a9450z9rzj3TN2vOODM/a748MzdrvjkzP2uuPTM3a644Yz9rnjpjN2uePGM/a44+YzdrjjjjPWv+OuM1a/484z1r7j7jNWvuOBM9a946EzVr3jwTPWvOPhM1a844kz1rvjqTNWu+PJM9a64+kzVrrjgDPWueOQM1a546Az1rjjsDNWuOPAM+a/49AzZr/j4DPmvuPwM2a+44Qz5r3jlDNmveOkM+a847QzZrzjxDPmu+PUM2a74+Qz5rrj9DNmuuOCM+a545IzZrnjojPmuOOyM2a448Izxr/j0jNGv+PiM8a+4/IzRr4DnDHuHeSMUe9AZ4x5BztjxDvgGePdQc8Y7Q58xlh38DNGumOAM8a5Y4gzRrljkDPGuGOYM0a4Y6Az/B1DnaHvGOwMe8dwZ8g7BjzD3THkGeqOQc8wdwx7hrhj4DOuv2PoM66+Y/Azrr1j+DOuvGOCM667Y4ozrrpjkjOuuWOaM664Y6Izzr9jqjPOvmOyM869Y7ozzrxjwjPOu2PKM866Y9Izzrlj2jPOuGPiM46/Y+ozjr5j8jOOvWP6M468Y4EzjrtjiTOOumORM465Y5kzjrhjoTOev2OpM569Y7EznrtjuTOeuWPBMx6/Y8kzHr1j0TMeu2PZMx65Y+Ez7r9j6TPuvWPxM+67Y/kz7rljgzNuv2OLM269Y5MzbrtjmzNuuWOjMz6/Y6szPrtjszM+vmO7Mz66Y8Mz3r9jyzPeu2PTM96+Y9sz3rpj4zP+vGPrM36/Y/Mzfr1j+zN+vuN1xj/+u+N1xr++3/E6I9/ueJ3xw9fXGT8b4owvX/4Gcx2ZdWMrVYAAAAAASUVORK5CYII=\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYoAAAENCAMAAAAmFdJCAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJUExURQAAAAAAAAAAAINj6cAAAAACdFJOUwCV9vaq8wAAAAlwSFlzAAAywAAAMsABKGRa2wAABUdJREFUeF7t1sl22zoUBdH4/f9HPzdlW7LYAOBtOKg9iUQBHJxaWck/6dEbf6rb2398ULO3/0xxD+8lTHELHyVMcQefJUxxA18lTNGPEqZo913CFN1+Spii2W8JU/R6KGGKVo8lTNHpqYQpGj2XMEWfPyVM0eZvCVN0eSlhiiavJUzRY6OEKVpslTBFh80SpmiwXcIU9XZKmKLcXglTVNstYYpi+yVMUeughClKHZUwRaXDEqYodFzCFHVOSpiizFkJU1Q5LWGKIuclTFFjoIQpSoyUMEWFoRKmKDBWwhT5BkuYIt1oCVNkGy5himTjJUyRa6KEKVLNlDBFpqkSpkg0V8IUeSZLmCLNbAlTZJkuYYok8yVMkWOhhClSrJQwRYalEqZIsFbCFPEWS5gi3GoJU0RbLmGKYOslTBHrQglThLpSwhSRLpUwRaBrJUwR52IJU4S5WsIUUS6XMEWQ6yVMESOghN4x5wWWCMKe6ywRhUGXWSIMi66yRBwmXWSJQGy6xhKRGHWJJUKx6gpLxGLWBZYIxq7zLBGNYadZIhzLzrJEPKadZIkEbDvHEhkYd4olUrDuDEvkYN4JlkjCvuMskYWBh1kiDQuPskQeJh5kiURsPMYSmRh5iCVSsfIIS+Ri5gGWSMbO5yyRjaFPWSIdS5+xRD6mPmGJAmx9zBIVGPuQJUqw9hFL1GDuA5Yowt77LFGFwXdZogyL77FEHSbfYYlCbL7NEpUYfZMlSrH6FkvUYvYNlijG7q8sUY3hX1iiHMv/ZYl6TP+HJRqw/TNLdGD8J5ZowfqPLNGD+R9Yogn7/7JEFwL8sEQbCnyzRB8SwBKNaPDFEp2I8MkSrajwwRK9yPDOEs3oYIl+hLBEP0vchiVuwxK3YYnbsMRtWOI2LHEb/q24Df+tuA3/B3UbHylscQufKWxxB18pbHEDpLBFP0rYoh8h3tmiGR0+2KIXGT7ZohUVvtiiExFgi0Y0+GaLPiT4YYs2FPhliy4EeGCLJuz/yBY9mP+JLVqw/jNbdGD8P2zRgO3/skU9pn9hi3Is/8oW1Rh+gy2KsfsWW9Ri9k22KMXq22xRidF32KIQm++xRR0m32WLMiy+zxZVGPyALYqw9xFb1GDuQ7YowdrHbFGBsU/YogBbn7FFPqY+ZYt0LH3OFtkYeoAtkrHzCFvkYuYhtkjFymNskYmRB9kiERuPskUeJh5mizQsPM4WWRh4gi2SsO8MW+Rg3im2SMG6c2yRgXEn2SIB286yRTymnWaLcCw7zxbRGHaBLYKx6wpbxGLWJbYIxaprbBGJURfZIhCbrrJFHCZdZoswLLrOFlEY9AJbBGHPK2wRgzkvCWjBm3TV9Ra8SJddbsF7dN3VFrxGAS624C2KcK0FL1GISy14h2JcacErFORCC96gKOsteIHCLLfgvuKstuC6Ai224LYirbXgskItteCuYq204KqCLbTgpqLNt+Ciwk234J7izbbgmhJMtuCWMsy14JJSTLXgjnLMtOCKkky04IayjLfggtIMt+C88oy24LgSDbbgtDKNteCwUg214KxyjbTgqJINtOCksp234KDSnbbgnPKdteCYCpy04JQqHLfgkEoctuCMahy14IiKHLTghKrst+CAyuy24HfV2WvBzyq004JfVWm7BT+q1GYLflOtrRb8pGIbLfhF1V5b8IPKvbTguer9bcFjNfjTgqfq8NyCh2rx1IJn6vHYgkdq8tCCJ+ry24IHavPTgu/q892Cr2pEC76p01cLvqjVZws+q9dHCz6q2XsLPqnbmylu440/pX7//v0PMbmZdSGwS8MAAAAASUVORK5CYII=\"","import GameScreen from \"./GameScreen\";\r\n\r\n\r\nfunction Game() {\r\n    let game = new GameScreen();\r\n    game.render();\r\n\r\n}\r\n export default Game;","import React from 'react';\r\nimport './index.css';\r\nimport Game from \"./gameplay-components/Game\";\r\n\r\nGame();\r\n\r\n\r\n"],"sourceRoot":""}